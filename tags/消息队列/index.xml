<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>消息队列 on Lin 的博客</title>
    <link>https://recordnote.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 消息队列 on Lin 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/4.0/&#34;&gt;&lt;img alt=&#34;知识共享许可协议&#34; style=&#34;border-width:0&#34; src=&#34;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&#34; /&gt;&lt;/a&gt;&lt;br /&gt;本作品采用&lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/4.0/&#34;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;br /&gt;&lt;br /&gt;背景使用了 &lt;a href=&#34;https://www.pexels.com/zh-cn/&#34; target=&#34;_blank&#34;&gt;Pexels&lt;/a&gt; 上 &lt;a href=&#34;https://www.pexels.com/zh-cn/Ungaro&#34; target=&#34;_blank&#34;&gt;Francesco Ungaro&lt;/a&gt; 拍摄的&lt;a href=&#34;https://www.pexels.com/zh-cn/photo/1454794/&#34; target=&#34;_blank&#34;&gt;图片&lt;/a&gt;。</copyright>
    <lastBuildDate>Sat, 01 Mar 2025 14:21:26 +0800</lastBuildDate><atom:link href="https://recordnote.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RocketMQ常见问题总结</title>
      <link>https://recordnote.github.io/mq/rocketmq%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 01 Mar 2025 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/rocketmq%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>深入剖析RocketMQ核心原理与最佳实践 一、消息队列的本质价值 1.1 从食堂打饭到餐厅点餐 传统同步调用如同食堂打饭场景： 用户线程阻塞等待所有操作</description>
    </item>
    
    <item>
      <title>RockerMQ总结</title>
      <link>https://recordnote.github.io/java/mq/</link>
      <pubDate>Wed, 15 Nov 2023 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/java/mq/</guid>
      <description>消息队列扫盲 消息队列顾名思义就是存放消息的队列， 消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作</description>
    </item>
    
    <item>
      <title>如果让你写一个消息队列，该如何进行架构设计？</title>
      <link>https://recordnote.github.io/mq/mq-design/</link>
      <pubDate>Fri, 28 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/mq-design/</guid>
      <description>可以从下几个角度来考虑一下： 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照</description>
    </item>
    
    <item>
      <title>如何保证消息的可靠性传输？（处理消息丢失的问题）</title>
      <link>https://recordnote.github.io/mq/how-to-ensure-the-reliable-transmission-of-messages/</link>
      <pubDate>Thu, 27 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/how-to-ensure-the-reliable-transmission-of-messages/</guid>
      <description>问题分析 数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。 RabbitMQ 生产者弄丢了数据 生产者将数据发送到 RabbitMQ 的时候，可能数</description>
    </item>
    
    <item>
      <title>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</title>
      <link>https://recordnote.github.io/mq/mq-time-delay-and-expired-failure/</link>
      <pubDate>Thu, 27 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/mq-time-delay-and-expired-failure/</guid>
      <description>大量消息在 mq 里积压了几个小时了还没解决 几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是真实遇到过的一个场景，确实</description>
    </item>
    
    <item>
      <title>如何保证消息的顺序性？</title>
      <link>https://recordnote.github.io/mq/how-to-ensure-the-order-of-messages/</link>
      <pubDate>Wed, 26 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/how-to-ensure-the-order-of-messages/</guid>
      <description>线上系统场景案例 以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（m</description>
    </item>
    
    <item>
      <title>如何保证消息不被重复消费？（如何保证消息消费的幂等性）</title>
      <link>https://recordnote.github.io/mq/how-to-ensure-that-messages-are-not-repeatedly-consumed/</link>
      <pubDate>Tue, 25 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/how-to-ensure-that-messages-are-not-repeatedly-consumed/</guid>
      <description>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开</description>
    </item>
    
    <item>
      <title>如何保证消息队列的高可用？</title>
      <link>https://recordnote.github.io/mq/how-to-ensure-high-availability-of-message-queues/</link>
      <pubDate>Mon, 24 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/how-to-ensure-high-availability-of-message-queues/</guid>
      <description>RabbitMQ 的高可用性 RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。 RabbitMQ 有三种模式：单机模</description>
    </item>
    
    <item>
      <title>为什么使用消息队列</title>
      <link>https://recordnote.github.io/mq/why-mq/</link>
      <pubDate>Sun, 23 Jan 2022 14:21:26 +0800</pubDate>
      
      <guid>https://recordnote.github.io/mq/why-mq/</guid>
      <description>为什么使用消息队列 消息队列有很多常见的使用场景，但是比较核心的有 3 个：解耦、异步、削峰。 解耦 看这么个场景。A 系统发送数据到 BCD 三个系统，通过接</description>
    </item>
    
  </channel>
</rss>
