<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>剑指offer算法题 | Lin 的博客</title>

    
<link href="/favicon.png" rel="shortcut icon" type="image/x-icon" />




<meta name="author" content="Lin" />
<meta name="description" content="Lin 的生活记录～" />



<meta name="generator" content="Hugo 0.123.2">

<link rel="canonical" href="https://recordnote.github.io/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87offer/" />


<meta property="og:title" content="剑指offer算法题" />
<meta property="og:description" content="1、JZ1 二维数组中的查找 描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://recordnote.github.io/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%89%91%E6%8C%87offer/" /><meta property="og:image" content="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728174624549.png" /><meta property="article:section" content="算法与数据结构" />
<meta property="article:published_time" content="2022-03-01T14:21:26+08:00" />
<meta property="article:modified_time" content="2022-05-22T14:21:26+08:00" />




<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728174624549.png" /><meta name="twitter:title" content="剑指offer算法题"/>
<meta name="twitter:description" content="1、JZ1 二维数组中的查找 描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序"/>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
<link rel="stylesheet" href="/css/icomoon.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/overlayscrollbars@1.13.1/css/OverlayScrollbars.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
<link rel="stylesheet" href="/css/site.css" />

<style>
  .ui.header a:not(.ui.button):hover {
    text-decoration: underline;
  }

  
  a:not(.ui.button) {
    color: seagreen !important;
  }
  

  
  .inverted a:not(.ui.button) {
     color: darkseagreen !important;
  }
  

  
  body.default {
    
    background-color: #fff;
    

    
    background-image: url(/me/background.jpg);
    
  }
  

  
  body.dark {
    
    background-color: #333;
    

    
    background-image: url(/me/background.jpg);
    
  }
  
</style>


    



<link rel="stylesheet" data-highlight href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/tomorrow.min.css" />







    
    <link rel="stylesheet" href="/css/custom.css" />
    
  </head>

  <body class="default">
    
<nav class="ui secondary menu dream-menu dream-nav">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/recordnote.github.io\/'"></i>
  </div>
  
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
  
  
  <div class="item">
    <i class="large link search icon" onclick="toggleSearch()"></i>
  </div>
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui relaxed centered grid dream-grid dream-grid-single">
  
  
  
  

  
  <aside class="sixteen wide mobile sixteen wide tablet three wide computer column dream-single-aside">
    
    <div class="ui segment toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#1jz1--二维数组中的查找">1、JZ1  二维数组中的查找</a></li>
    <li><a href="#2jz2--替换空格">2、JZ2  替换空格</a></li>
    <li><a href="#3jz3--从尾到头打印链表">3、JZ3  从尾到头打印链表</a></li>
    <li><a href="#4jz4--重建二叉树">4、JZ4  重建二叉树</a>
      <ul>
        <li><a href="#font-colorred补充知识font"><strong><font color='red'>补充知识：</font></strong></a></li>
        <li><a href="#题解递归构建二叉树">题解：递归构建二叉树</a></li>
      </ul>
    </li>
    <li><a href="#5jz5-用两个栈实现队列">5、JZ5 用两个栈实现队列</a></li>
    <li><a href="#6jz6-旋转数组的最小数字">6、<strong>JZ6</strong> <strong>旋转数组的最小数字</strong></a>
      <ul>
        <li><a href="#题解-采用二分法">题解 ：采用二分法</a></li>
      </ul>
    </li>
    <li><a href="#7jz7-斐波那契数列">7、<strong>JZ7</strong> <strong>斐波那契数列</strong></a></li>
    <li><a href="#8jz8-青蛙跳台阶">8、<strong>JZ8</strong> <strong>青蛙跳台阶</strong></a></li>
    <li><a href="#9jz9-青蛙跳台阶扩展问题变态版">9、<strong>JZ9</strong> <strong>青蛙跳台阶扩展问题（变态版）</strong></a></li>
    <li><a href="#10jz10-矩形覆盖">10、<strong>JZ10</strong> <strong>矩形覆盖</strong></a>
      <ul>
        <li><a href="#分析-1">分析：</a></li>
        <li><a href="#题解">题解：</a></li>
      </ul>
    </li>
    <li><a href="#11-jz11-二进制中1的个数">11、 <strong>JZ11</strong> <strong>二进制中1的个数</strong></a></li>
    <li><a href="#12jz12-数值的整数次方">12、<strong>JZ12</strong> <strong>数值的整数次方</strong></a>
      <ul>
        <li><a href="#分析-2">分析：</a></li>
        <li><a href="#题解-1">题解：</a></li>
      </ul>
    </li>
    <li><a href="#13-jz13-调整数组顺序使奇数位于偶数前面">13、 <strong>JZ13</strong> <strong>调整数组顺序使奇数位于偶数前面</strong></a></li>
    <li><a href="#14jz14-链表中倒数最后k个结点">14、<strong>JZ14</strong> <strong>链表中倒数最后k个结点</strong></a></li>
    <li><a href="#15jz15-反转链表">15、<strong>JZ15</strong> <strong>反转链表</strong></a></li>
    <li><a href="#16jz16-合并两个排序的链表">16、<strong>JZ16</strong> <strong>合并两个排序的链表</strong></a></li>
    <li><a href="#17jz17-树的子结构">17、<strong>JZ17</strong> <strong>树的子结构</strong></a></li>
    <li><a href="#18jz18-二叉树的镜像">18、<strong>JZ18</strong> <strong>二叉树的镜像</strong></a></li>
    <li><a href="#19-jz19-顺时针打印矩阵">19、 <strong>JZ19</strong> <strong>顺时针打印矩阵</strong></a></li>
    <li><a href="#20jz20-包含min函数的栈">20、<strong>JZ20</strong> <strong>包含min函数的栈</strong></a></li>
    <li><a href="#21jz21-栈的压入弹出序列">21、<strong>JZ21</strong> <strong>栈的压入、弹出序列</strong></a></li>
    <li><a href="#22jz22-从上往下打印二叉树">22、<strong>JZ22</strong> <strong>从上往下打印二叉树</strong></a></li>
    <li><a href="#23jz23-二叉搜索树的后序遍历序列">23、<strong>JZ23</strong> <strong>二叉搜索树的后序遍历序列</strong></a></li>
    <li><a href="#24jz24-二叉树中和为某一值的路径">24、<strong>JZ24</strong> <strong>二叉树中和为某一值的路径</strong></a></li>
    <li><a href="#25jz25-复杂链表的复制">25、<strong>JZ25</strong> <strong>复杂链表的复制</strong></a></li>
    <li><a href="#26jz26-二叉搜索树与双向链表">26、<strong>JZ26</strong> <strong>二叉搜索树与双向链表</strong></a></li>
    <li><a href="#27jz27-字符串的排列">27、<strong>JZ27</strong> <strong>字符串的排列</strong></a></li>
    <li><a href="#28-jz28-数组中出现次数超过一半的数字">28、 <strong>JZ28</strong> <strong>数组中出现次数超过一半的数字</strong></a></li>
  </ul>
</nav>
    </div>
    

    
  </aside>
  
  <div class="sixteen wide mobile sixteen wide tablet ten wide computer column markdown-body dream-single" id="dream-save-post-as-img">
    <section class="ui top attached segment">
      <header>
        <h1 class="ui large header">剑指offer算法题<span class="sub header">
            <span class="left">
              @
              
                
                  Aaron
                
              

              | 
                  <span data-format="luxon">2022-03-01T14:21:26&#43;08:00</span>
                

              | 23 分钟阅读

              
              | 更新于
                
                  <span data-format="luxon">2022-05-22T14:21:26&#43;08:00</span>
                
              
            </span>

            
            <span class="dream-share">
  <a href="#" class="save-as-image" title="保存为图片" onclick="savePostAsImg()">
    <i class="save icon"></i>
  </a>
  <a href="https://twitter.com/intent/tweet?text=%e5%89%91%e6%8c%87offer%e7%ae%97%e6%b3%95%e9%a2%98&url=https%3a%2f%2frecordnote.github.io%2f%25E7%25AE%2597%25E6%25B3%2595%25E4%25B8%258E%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2f%25E5%2589%2591%25E6%258C%2587offer%2f" title="Twitter">
    <i class="twitter icon"></i>
  </a>
  <a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frecordnote.github.io%2f%25E7%25AE%2597%25E6%25B3%2595%25E4%25B8%258E%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2f%25E5%2589%2591%25E6%258C%2587offer%2f" title="Facebook">
    <i class="facebook icon"></i>
  </a>
</span>

            
          </span>
        </h1>
      </header>

      <article class="main">
        
        <img class="cover" src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728174624549.png" />
        

        <h2 id="1jz1--二维数组中的查找">1、JZ1  二维数组中的查找</h2>
<p>描述</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>[</p>
<p>[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]</p>
<p>]</p>
<p>给定 target = 7，返回 true。</p>
<p>给定 target = 3，返回 false。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/* 思路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 因此从左下角开始查找，当要查找数字比左下角数字大时。右移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 要查找数字比左下角数字小时，上移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> target, <span style="color:#66d9ef">int</span> <span style="color:#f92672">[][]</span> array) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rows <span style="color:#f92672">=</span> array.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rows <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cols <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>.<span style="color:#a6e22e">length</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(cols <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 左下</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> rows<span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(row<span style="color:#f92672">&gt;=</span>0 <span style="color:#f92672">&amp;&amp;</span> col<span style="color:#f92672">&lt;</span>cols){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>row<span style="color:#f92672">][</span>col<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> target){
</span></span><span style="display:flex;"><span>                col<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>row<span style="color:#f92672">][</span>col<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> target){
</span></span><span style="display:flex;"><span>                row<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2jz2--替换空格">2、JZ2  替换空格</h2>
<p>描述</p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>&#34;We Are Happy&#34;
</code></pre><p>复制</p>
<p>返回值：</p>
<pre tabindex="0"><code>&#34;We%20Are%20Happy&#34;
</code></pre><p>题解：</p>
<p>两种方法，思路一样</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//解法一</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">replaceSpace</span> (String s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> s.<span style="color:#a6e22e">length</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>length<span style="color:#f92672">*</span>3<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span> 0; i<span style="color:#f92672">&lt;</span> length ;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> c<span style="color:#f92672">=</span> s.<span style="color:#a6e22e">charAt</span>(i);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>){
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>index<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>;
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>index<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2&#39;</span>;
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>index<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>index<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        String newStr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String (array,0,index);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> newStr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//解法二</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">replaceSpace</span> (String s) {
</span></span><span style="display:flex;"><span>        StringBuilder stringBuilder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span> 0 ; i <span style="color:#f92672">&lt;</span> s.<span style="color:#a6e22e">length</span>(); i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(s.<span style="color:#a6e22e">charAt</span>(i) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39; &#39;</span>){
</span></span><span style="display:flex;"><span>                stringBuilder.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;%20&#34;</span>);
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                stringBuilder.<span style="color:#a6e22e">append</span>(s.<span style="color:#a6e22e">charAt</span>(i));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stringBuilder.<span style="color:#a6e22e">toString</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="3jz3--从尾到头打印链表">3、JZ3  从尾到头打印链表</h2>
<p>描述</p>
<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>
<p>如输入{1,2,3}的链表如下图:</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721102102786.png" alt="image-20210721102102786"></p>
<p>返回一个数组为[3,2,1]</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
<p>示例</p>
<p>输入：</p>
<pre tabindex="0"><code>{67,0,24,58}
</code></pre><p>复制</p>
<p>返回值：</p>
<pre tabindex="0"><code>[58,24,0,67]
</code></pre><p>题解</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">三种方法： 前两种O（n），第三种O（2n）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">复杂度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">时间复杂度：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">空间复杂度：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**第一种 非递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">listNode 是链表，只能从头遍历到尾，但是输出却要求从尾到头，这是典型的&#34;先进后出&#34;，我们可以想到栈！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">ArrayList 中有个方法是 add(index,value)，可以指定 index 位置插入 value 值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">所以我们在遍历 listNode 的同时将每个遇到的值插入到 list 的 0 位置，最后输出 listNode 即可得到逆序链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">printListFromTailToHead</span>(ListNode listNode) {
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        ListNode tmp <span style="color:#f92672">=</span> listNode;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(tmp<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            list.<span style="color:#a6e22e">add</span>(0,tmp.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>            tmp <span style="color:#f92672">=</span> tmp.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**第二种 递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">既然非递归都实现了，那么我们也可以利用递归，借助系统的&#34;栈&#34;帮忙打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">printListFromTailToHead</span>(ListNode listNode) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(listNode<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            printListFromTailToHead(listNode.<span style="color:#a6e22e">next</span>);
</span></span><span style="display:flex;"><span>            list.<span style="color:#a6e22e">add</span>(listNode.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**第三种
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">遍历值给数组，数组反转，返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">printListFromTailToHead</span>(ListNode listNode) {
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arrays <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>         ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arrays2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(ListNode p <span style="color:#f92672">=</span> listNode; p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>; p <span style="color:#f92672">=</span> p.<span style="color:#a6e22e">next</span>){
</span></span><span style="display:flex;"><span>            arrays.<span style="color:#a6e22e">add</span>(p.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arrays.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">-</span> 1; i <span style="color:#f92672">&gt;=</span> 0; i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            arrays2.<span style="color:#a6e22e">add</span>(arrays.<span style="color:#a6e22e">get</span>(i));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arrays2;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4jz4--重建二叉树">4、JZ4  重建二叉树</h2>
<p>描述</p>
<p>给定某二叉树的前序遍历和中序遍历，请重建出该二叉树并返回它的头结点。</p>
<p>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721102138599.png" alt="image-20210721102138599" style="zoom:67%;" />
<p>提示:</p>
<p>1.0 &lt;= pre.length &lt;= 2000</p>
<p>2.vin.length == pre.length</p>
<p>3.0 &lt;= pre[i], vin[i] &lt;= 10000</p>
<p>4.pre 和 vin 均无重复元素</p>
<p>5.vin出现的元素均出现在 pre里</p>
<p>6.只需要返回根结点，系统会自动输出整颗树做答案对比</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{1,2,3,4,#,5,6,#,7,#,#,8}
</code></pre><p>说明：</p>
<pre tabindex="0"><code>返回根节点，系统会输出整颗二叉树对比结果     
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>[1],[1]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{1}
</code></pre><p>示例3</p>
<p>输入：</p>
<pre tabindex="0"><code>[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{1,2,5,3,4,6,7}
</code></pre><h3 id="font-colorred补充知识font"><strong><font color='red'>补充知识：</font></strong></h3>
<p><font color='red'><strong>二叉树的前序、中序、后序遍历</strong></font></p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210720100922944.png" alt="image-20210720100922944" style="zoom:80%;" /> 
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>前序遍历A-B-D-F-G-H-I-E-C
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>中序遍历F-D-H-G-I-B-E-A-C
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>后序遍历F-H-I-G-D-E-B-C-A
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>前序(根左右)，中序(左根右)，后序(左右根)
</span></span></code></pre></div><h3 id="题解递归构建二叉树">题解：递归构建二叉树</h3>
<h4 id="1-分析">1. 分析</h4>
<p>根据中序遍历和前序遍历可以确定二叉树，具体过程为：</p>
<ol>
<li>根据前序序列第一个结点确定根结点</li>
<li>根据根结点在中序序列中的位置分割出左右两个子序列</li>
<li>对左子树和右子树分别递归使用同样的方法继续分解</li>
</ol>
<p>例如：
前序序列{1,2,4,7,3,5,6,8} = pre
中序序列{4,7,2,1,5,3,8,6} = in</p>
<ol>
<li>
<p>根据当前前序序列的第一个结点确定根结点，为 1</p>
</li>
<li>
<p>找到 1 在中序遍历序列中的位置，为 in[3]</p>
</li>
<li>
<p>切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树</p>
</li>
<li>
<p>则切割后的<strong>左子树前序序列</strong>为：{2,4,7}，切割后的<strong>左子树中序序列</strong>为：{4,7,2}；切割后的<strong>右子树前序序列</strong>为：{3,5,6,8}，切割后的<strong>右子树中序序列</strong>为：{5,3,8,6}</p>
</li>
<li>
<p>对子树分别使用同样的方法分解</p>
</li>
</ol>
<h4 id="2-代码">2. 代码</h4>
<p>复杂度</p>
<p>时间复杂度：O(n)
空间复杂度：O(n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for binary tree
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * public class TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) { val = x; }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Arrays;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">reConstructBinaryTree</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> pre,<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> in) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pre.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> in.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(pre<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在中序中找到前序的根</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> in.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (in<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> pre<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 左子树，注意 copyOfRange 函数，左闭右开</span>
</span></span><span style="display:flex;"><span>                root.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> reConstructBinaryTree(Arrays.<span style="color:#a6e22e">copyOfRange</span>(pre, 1, i <span style="color:#f92672">+</span> 1), Arrays.<span style="color:#a6e22e">copyOfRange</span>(in, 0, i));
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 右子树，注意 copyOfRange 函数，左闭右开</span>
</span></span><span style="display:flex;"><span>                root.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> reConstructBinaryTree(Arrays.<span style="color:#a6e22e">copyOfRange</span>(pre, i <span style="color:#f92672">+</span> 1, pre.<span style="color:#a6e22e">length</span>), Arrays.<span style="color:#a6e22e">copyOfRange</span>(in, i <span style="color:#f92672">+</span> 1, in.<span style="color:#a6e22e">length</span>));
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="5jz5-用两个栈实现队列">5、JZ5 用两个栈实现队列</h2>
<p>描述</p>
<p>用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<p>示例:</p>
<p>输入:</p>
<p>[&ldquo;PSH1&rdquo;,&ldquo;PSH2&rdquo;,&ldquo;POP&rdquo;,&ldquo;POP&rdquo;]</p>
<p>返回:</p>
<p>1,2</p>
<p>解析:</p>
<p>&ldquo;PSH1&rdquo;:代表将1插入队列尾部</p>
<p>&ldquo;PSH2&rdquo;:代表将2插入队列尾部</p>
<p>&ldquo;POP“:代表删除一个元素，先进先出=&gt;返回1</p>
<p>&ldquo;POP“:代表删除一个元素，先进先出=&gt;返回2</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[&#34;PSH1&#34;,&#34;PSH2&#34;,&#34;POP&#34;,&#34;POP&#34;]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>1,2
</code></pre><p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">思路：两个栈做相反操作 等于 队列的先进先出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>    Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> node) {
</span></span><span style="display:flex;"><span>        stack1.<span style="color:#a6e22e">push</span>(node);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(stack2.<span style="color:#a6e22e">empty</span>()){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stack1.<span style="color:#a6e22e">empty</span>()){
</span></span><span style="display:flex;"><span>               stack2.<span style="color:#a6e22e">push</span>(stack1.<span style="color:#a6e22e">pop</span>());
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stack2.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="6jz6-旋转数组的最小数字">6、<strong>JZ6</strong> <strong>旋转数组的最小数字</strong></h2>
<p>描述</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[3,4,5,1,2]
</code></pre><p>复制</p>
<p>返回值：</p>
<pre tabindex="0"><code>1
</code></pre><h3 id="题解-采用二分法">题解 ：采用二分法</h3>
<h4 id="分析">分析：</h4>
<p>采用二分法解答这个问题，</p>
<p>mid = low + (high - low)/2</p>
<p>需要考虑三种情况：</p>
<p>(1)array[mid] &gt; array[high]:</p>
<p>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。</p>
<p>low = mid + 1</p>
<p>(2)array[mid] == array[high]:</p>
<p>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边</p>
<p>还是右边,这时只好一个一个试 ，</p>
<p>high = high - 1</p>
<p>(3)array[mid] &lt; array[high]:</p>
<p>出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左</p>
<p>边。因为右边必然都是递增的。</p>
<p>high = mid</p>
<p><strong>注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid</strong> <strong>一定会指向下标靠前的数字</strong></p>
<p>比如 array = [4,6]</p>
<p>array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;</p>
<p>如果high = mid - 1，就会产生错误， 因此high = mid</p>
<p>但情形(1)中low = mid + 1就不会错误</p>
<h4 id="代码">代码：</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minNumberInRotateArray</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> array) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> 0 ; <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> array.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;   
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(low <span style="color:#f92672">&lt;</span> high){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> 2;        
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(array<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span>){
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> high <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>            }   
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="7jz7-斐波那契数列">7、<strong>JZ7</strong> <strong>斐波那契数列</strong></h2>
<p>描述</p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p>
<p><em>n</em>≤39</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>4
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>3
</code></pre><p>题解：**f(n) = f(n-1) + f(n-2)  **     <font color='red'> <strong>0 1 1 2 3 5</strong></font></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第一种用递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(2^n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度：递归栈的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Fibonacci</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> n <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Fibonacci(n<span style="color:#f92672">-</span>1) <span style="color:#f92672">+</span> Fibonacci(n<span style="color:#f92672">-</span>2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第二种 动态规划
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度：O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Fibonacci</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> n <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0, b <span style="color:#f92672">=</span> 1, c <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            c <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="8jz8-青蛙跳台阶">8、<strong>JZ8</strong> <strong>青蛙跳台阶</strong></h2>
<p>描述</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>2
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>2
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>7
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>21
</code></pre><p>题解:</p>
<p>分析：</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210720204449750.png" alt="image-20210720204449750"></p>
<p><a href="https://blog.csdn.net/weixin_42292229/article/details/104505402">斐波那契数列（四种解法）</a></p>
<pre tabindex="0"><code>一阶：口
1
有1种跳法

二阶：口口
1  1
2
有2种跳法

三阶：口口口
 1 1 1
 1 2
 2 1
有3种跳法

四阶口口口口
1 1 1 1
1 1 2
1 2 1
2 1
2 2
有5种跳法

跳法规律  ： 1 2 3 5 .......
f(n) = f(n-1) + f(n-2)
</code></pre><p><strong>方法一：</strong>
面试别写型递推版实现，时间复杂度 <em>O</em>(2^n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">JumpFloor</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> 1) <span style="color:#66d9ef">return</span> 1; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> 2) <span style="color:#66d9ef">return</span> 2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> JumpFloor(n <span style="color:#f92672">-</span> 1) <span style="color:#f92672">+</span> JumpFloor(n <span style="color:#f92672">-</span> 2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>方法二：</strong>
自底向上型循环求解，时间复杂度为 O(n)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jumpFloor</span>(<span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(target <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> target <span style="color:#f92672">==</span> 1 <span style="color:#f92672">||</span> target <span style="color:#f92672">==</span> 2){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 1, b <span style="color:#f92672">=</span> 2, c <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 3; i <span style="color:#f92672">&lt;=</span> target; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            c <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="9jz9-青蛙跳台阶扩展问题变态版">9、<strong>JZ9</strong> <strong>青蛙跳台阶扩展问题（变态版）</strong></h2>
<p>描述</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>3
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>4
</code></pre><p>分析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>4阶 口口口口
</span></span><span style="display:flex;"><span>1 1 1 1
</span></span><span style="display:flex;"><span>1 1 2
</span></span><span style="display:flex;"><span>1 2 1
</span></span><span style="display:flex;"><span>1 3
</span></span><span style="display:flex;"><span>2 1 1
</span></span><span style="display:flex;"><span>2 2
</span></span><span style="display:flex;"><span>3 1
</span></span><span style="display:flex;"><span>4
</span></span><span style="display:flex;"><span>总共8种跳法
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>3阶 口口口
</span></span><span style="display:flex;"><span>1 1 1
</span></span><span style="display:flex;"><span>1 2
</span></span><span style="display:flex;"><span>2 1
</span></span><span style="display:flex;"><span>3
</span></span><span style="display:flex;"><span>总共4种跳法
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>2阶 口口口
</span></span><span style="display:flex;"><span>1 1
</span></span><span style="display:flex;"><span>2
</span></span><span style="display:flex;"><span>总共2种跳法
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1阶 口
</span></span><span style="display:flex;"><span>1
</span></span><span style="display:flex;"><span>总共1种
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>跳法： 1 2 4 8 ... 2^(n-1)
</span></span></code></pre></div><p><strong>【分析】</strong>
每个台阶可以看作一块木板，让青蛙跳上去，n个台阶就有n块木板，最后一块木板是青蛙到达的位子，
必须存在，其他 (n-1) 块木板可以任意选择是否存在，则每个木板有存在和不存在两种选择，(n-1) 块木板
就有 [2^(n-1)] 种跳法，可以直接得到结果。</p>
<p>其实我们所要求的序列为：0,1,2,4,8,16,……</p>
<p><strong><font color='red'>所以除了第一位外，其他位的数都是前一位的数去乘以2所得到的积。</font></strong></p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第一种写法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jumpFloorII</span>(<span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(target <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i <span style="color:#f92672">&lt;=</span> target <span style="color:#f92672">-</span> 1; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">*=</span> 2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第二种写法 递归
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jumpFloorII</span>(<span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(target <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(target <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 2<span style="color:#f92672">*</span>jumpFloorII(target <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        }   
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="10jz10-矩形覆盖">10、<strong>JZ10</strong> <strong>矩形覆盖</strong></h2>
<p>描述</p>
<p>我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2X1的小矩形无重叠地覆盖一个2xn的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721141607160.png" alt="image-20210721141607160" style="zoom: 50%;" /> 
<p>输入描述：</p>
<p>2*1的小矩形的总个数n</p>
<p>返回值描述：</p>
<p>覆盖一个2*n的大矩形总共有多少种不同的方法(从同一个方向看)</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>0
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>0
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>1
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>1
</code></pre><p>示例3</p>
<p>输入：</p>
<pre tabindex="0"><code>4
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>5
</code></pre><h3 id="分析-1">分析：</h3>
<p>递推</p>
<p>对于这种题没有思路怎么办？</p>
<p>那就对n 从小到大，一步步分析：</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721160942885.png" alt="image-20210721160942885"></p>
<p>n=1时，显然只有一种方法</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721161015941.png" alt="image-20210721161015941"></p>
<p>n=2时，如图有2种方法</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721161028733.png" alt="image-20210721161028733"></p>
<p>n=3，如图有3中方法</p>
 <img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210721161053281.png" style="zoom: 80%;" />
<p>n=4,如图有5种方法。</p>
<p>如果到这里，还没有发现规律怎么办呢？</p>
<p>那我们就再分析以下，从n=3到n=4，怎么来的呢？</p>
<p>这里有2种情况：</p>
<ul>
<li>直接在n=3的情况下，再后面中添加一个竖着的。这个很显然成立，有3种情况</li>
<li>然后横着的显然能添加到n-2的情况上，也就是在n=2后面，添加2个横着的。有2种情况</li>
</ul>
<p>通过以上分析，发现刚好和图中的个数一样。</p>
<p>所以总结：f [n]表示2*n大矩阵 的方法数。</p>
<p>可以得出：f[n] = f[n-1] + f[n-2]，初始条件f[1] = 1, f[2] =2</p>
<p>所以代码可用递归，记忆递归，和动态规划和递推</p>
<h3 id="题解">题解：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rectCover</span>(<span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(target <span style="color:#f92672">&lt;=</span> 2){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> target;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 1, b <span style="color:#f92672">=</span> 2, c <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 3;i<span style="color:#f92672">&lt;=</span> target;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            c <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="11-jz11-二进制中1的个数">11、 <strong>JZ11</strong> <strong>二进制中1的个数</strong></h2>
<p>描述</p>
<p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>10
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>2
</code></pre><p>分析：</p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。
举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作</p>
<p><strong><font color='red'>补充知识：</font></strong></p>
<p>1）与运算符（&amp;）</p>
<p>运算规则：</p>
<p>0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1</p>
<p>即：<font color='red'><strong>两个同时为1，结果为1</strong></font>，否则为0</p>
<p>例如：3&amp;5</p>
<p>十进制3转为二进制的3：0000 0011</p>
<p>十进制5转为二进制的5：0000 0101</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;结果：0000 0001 -&gt;转为十进制：1</p>
<p>即：3&amp;5 = 1</p>
<p>2）或运算（|）</p>
<p>运算规则：</p>
<p>0|0=0； 0|1=1； 1|0=1；  1|1=1；</p>
<p>即 ：参加运算的两个对象，<font color='red'><strong>一个为1，其值为1</strong></font></p>
<p>例如：3|5　即 00000011 | 0000 0101 = 00000111，因此，3|5=7。　</p>
<p>3）异或运算符（^）</p>
<p>运算规则：0^0=0； 0^1=1； 1^0=1；  1^1=0；</p>
<p>即：参加运算的两个对象，如果两个位为<font color='red'><strong>“异”（值不同），则该位结果为1</strong></font>，否则为0。</p>
<p>例如：3^5 = 0000 0011 | 0000 0101 =0000 0110，因此，3^5 = 6</p>
<p><a href="https://blog.csdn.net/baidu_35679960/article/details/80364315"><strong>负数补码表示</strong></a></p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">NumberOf1</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span>0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(n<span style="color:#f92672">!=</span>0){
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            n<span style="color:#f92672">=</span>n<span style="color:#f92672">&amp;</span>(n<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="12jz12-数值的整数次方">12、<strong>JZ12</strong> <strong>数值的整数次方</strong></h2>
<p>描述</p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>2.00000,3
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>8.00000
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>2.10000,3
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>9.26100
</code></pre><p>示例3</p>
<p>输入：</p>
<pre tabindex="0"><code>2.00000,-2
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>0.25000
</code></pre><p>说明：</p>
<pre tabindex="0"><code>2的-2次方等于1/4=0.25
</code></pre><h3 id="分析-2">分析：</h3>
<p>第一种 暴力法</p>
<p>第二种 递归法（快速幂）</p>
 <img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210723105148744.png" alt="image-20210723105148744" style="zoom:80%;" />
<p>第三种 非递归的快速幂</p>
<p><img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210723111649577.png" alt="image-20210723111649577"></p>
<h3 id="题解-1">题解：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//第一种 暴力法 </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//时间复杂度：O(n)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//空间复杂度：O(1)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Power</span>(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">int</span> exponent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(exponent <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(exponent <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> base;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> exponent <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">?</span> exponent : <span style="color:#f92672">-</span>exponent;
</span></span><span style="display:flex;"><span>        Double result <span style="color:#f92672">=</span> 1.<span style="color:#a6e22e">0d</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1; i<span style="color:#f92672">&lt;=</span>e; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">*=</span> base;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> exponent <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">?</span> result : 1<span style="color:#f92672">/</span>result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第二种 递归法（快速幂）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(logn)，每次规模减少一半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度：O(logn)，递归栈，因为要记住logn个变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Power</span>(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">int</span> exponent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(exponent<span style="color:#f92672">&lt;</span>0){
</span></span><span style="display:flex;"><span>            exponent <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>exponent;
</span></span><span style="display:flex;"><span>            base <span style="color:#f92672">=</span> 1<span style="color:#f92672">/</span>base;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(exponent <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 1.<span style="color:#a6e22e">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> ret <span style="color:#f92672">=</span> Power(base, exponent<span style="color:#f92672">/</span>2);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>((exponent<span style="color:#f92672">&amp;</span>1) <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//指数为奇数</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> ret<span style="color:#f92672">*</span>ret<span style="color:#f92672">*</span>base;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> ret<span style="color:#f92672">*</span>ret;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第三种 非递归的快速幂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(logn)，因为n的二进制位个数为logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度：O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">Power</span>(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">int</span> exponent) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (exponent <span style="color:#f92672">&lt;</span> 0) {
</span></span><span style="display:flex;"><span>            base <span style="color:#f92672">=</span> 1 <span style="color:#f92672">/</span> base;
</span></span><span style="display:flex;"><span>            exponent <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>exponent;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> x <span style="color:#f92672">=</span> base; <span style="color:#75715e">// 记录x^0, x^1, x^2 ...</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> ret <span style="color:#f92672">=</span> 1.<span style="color:#a6e22e">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (exponent <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((exponent<span style="color:#f92672">&amp;</span>1) <span style="color:#f92672">==</span> 1) {
</span></span><span style="display:flex;"><span>                ret <span style="color:#f92672">*=</span> x; <span style="color:#75715e">// 二进制位数是1的，乘进答案。</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">*=</span> x;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//指数位数右移一位</span>
</span></span><span style="display:flex;"><span>            exponent <span style="color:#f92672">&gt;&gt;=</span> 1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="13-jz13-调整数组顺序使奇数位于偶数前面">13、 <strong>JZ13</strong> <strong>调整数组顺序使奇数位于偶数前面</strong></h2>
<p>描述</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[1,2,3,4]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[1,3,2,4]
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>[2,4,6,5,7]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[5,7,2,4,6]
</code></pre><p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">reOrderArray</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array) {
</span></span><span style="display:flex;"><span>        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> oddQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> evenQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> array.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>((array<span style="color:#f92672">[</span>i<span style="color:#f92672">]&amp;</span>1) <span style="color:#f92672">==</span> 1){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//为奇数</span>
</span></span><span style="display:flex;"><span>                oddQueue.<span style="color:#a6e22e">add</span>(array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                evenQueue.<span style="color:#a6e22e">add</span>(array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> array.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>oddQueue.<span style="color:#a6e22e">isEmpty</span>()){
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> oddQueue.<span style="color:#a6e22e">poll</span>();
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> evenQueue.<span style="color:#a6e22e">poll</span>();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> array;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="14jz14-链表中倒数最后k个结点">14、<strong>JZ14</strong> <strong>链表中倒数最后k个结点</strong></h2>
<p>描述</p>
<p>输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第k个结点至尾节点的全部节点。</p>
<p>如果该链表长度小于k，请返回一个长度为 0 的链表。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{1,2,3,4,5},1 
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{5}
</code></pre><p>分析：</p>
<p>在链表中：倒数的+顺数的长度等于链表总长度，所以可以设置两个指针，一个先走K步，剩下的到链表的末尾要走的步数就是倒数第k个节点，需要从头开始走的步数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * public class ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   ListNode next = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   public ListNode(int val) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     this.val = val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param pHead ListNode类 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param k int整型 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return ListNode类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">FindKthToTail</span> (ListNode pHead, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pHead <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ListNode first <span style="color:#f92672">=</span> pHead;
</span></span><span style="display:flex;"><span>        ListNode second <span style="color:#f92672">=</span> pHead;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> k; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(first <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断k可能大于链表节点数，</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//第一个指针走k个位置</span>
</span></span><span style="display:flex;"><span>            first <span style="color:#f92672">=</span> first.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (first <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//第一个指针走完最后一步，第二个指针的位置就是倒数k</span>
</span></span><span style="display:flex;"><span>            first <span style="color:#f92672">=</span> first.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            second <span style="color:#f92672">=</span> second.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> second;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="15jz15-反转链表">15、<strong>JZ15</strong> <strong>反转链表</strong></h2>
<p>描述</p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{1,2,3}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{3,2,1}
</code></pre><p>分析：</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210727153028017.png" alt="image-20210727153028017" style="zoom:80%;" /> 
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210727152952167.png" alt="image-20210727152952167" style="zoom:80%;" /> 
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">public class ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    ListNode next = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    ListNode(int val) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        this.val = val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">ReverseList</span>(ListNode head) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ListNode pre <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        ListNode cur <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//反转 ==》指针反转</span>
</span></span><span style="display:flex;"><span>            ListNode next <span style="color:#f92672">=</span> cur.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            cur.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> pre;
</span></span><span style="display:flex;"><span>            pre <span style="color:#f92672">=</span> cur;	
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pre;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="16jz16-合并两个排序的链表">16、<strong>JZ16</strong> <strong>合并两个排序的链表</strong></h2>
<p>描述</p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{1,3,5},{2,4,6}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{1,2,3,4,5,6}
</code></pre><p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第一种
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">Merge</span>(ListNode list1,ListNode list2) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(list1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> list2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ListNode head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(0); <span style="color:#75715e">//用来做合并的链表</span>
</span></span><span style="display:flex;"><span>        ListNode root <span style="color:#f92672">=</span> head; <span style="color:#75715e">//保存头节点引用</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(list1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> list2 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(list1.<span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;</span> list2.<span style="color:#a6e22e">val</span>){
</span></span><span style="display:flex;"><span>                head.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> list1;
</span></span><span style="display:flex;"><span>                list1 <span style="color:#f92672">=</span> list1.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                head.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> list2;
</span></span><span style="display:flex;"><span>                list2 <span style="color:#f92672">=</span> list2.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            head <span style="color:#f92672">=</span> head.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//考虑可能会有一个链表走完的情况，将未走完链表接在合并链表后面</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            head.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> list2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            head.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> list1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>  root.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*第二种
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*递归版本，可以练习递归代码。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*写递归代码，最重要的要明白递归函数的功能。可以不必关心递归函数的具体实现。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*比如这个ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*函数功能：合并两个单链表，返回两个单链表头结点值小的那个节点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(m+n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*空间复杂度：O(m+n),每一次递归，递归栈都会保存一个变量，最差情况会保存(m+n)个变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ListNode <span style="color:#a6e22e">Merge</span>(ListNode list1,ListNode list2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(list1.<span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;</span> list2.<span style="color:#a6e22e">val</span>){
</span></span><span style="display:flex;"><span>            list1.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> Merge(list1.<span style="color:#a6e22e">next</span>, list2);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>       }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>           list2.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> Merge(list1, list2.<span style="color:#a6e22e">next</span>);
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="17jz17-树的子结构">17、<strong>JZ17</strong> <strong>树的子结构</strong></h2>
<p>描述</p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{8,8,#,9,#,2,#,5},{8,9,#,2}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>true
</code></pre><p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">public class TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int val = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    TreeNode left = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    TreeNode right = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    public TreeNode(int val) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        this.val = val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">HasSubtree</span>(TreeNode root1,TreeNode root2) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">boolean</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root2 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> root1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果找到了对应Tree2的根节点的点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(root1.<span style="color:#a6e22e">val</span> <span style="color:#f92672">==</span> root2.<span style="color:#a6e22e">val</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//以这个根节点为为起点判断是否包含Tree2</span>
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">=</span> doesTree1HaveTree2(root1,root2);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result) {
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">=</span> HasSubtree(root1.<span style="color:#a6e22e">left</span>,root2);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>result) {
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">=</span> HasSubtree(root1.<span style="color:#a6e22e">right</span>,root2);
</span></span><span style="display:flex;"><span>               }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//返回结果</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">doesTree1HaveTree2</span>(TreeNode node1, TreeNode node2) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果Tree2已经遍历完了都能对应的上，返回true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果其中有一个点没有对应上，返回false</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node1.<span style="color:#a6e22e">val</span> <span style="color:#f92672">!=</span> node2.<span style="color:#a6e22e">val</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果根节点对应的上，那么就分别去子节点里面匹配</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> doesTree1HaveTree2(node1.<span style="color:#a6e22e">left</span>,node2.<span style="color:#a6e22e">left</span>) <span style="color:#f92672">&amp;&amp;</span> doesTree1HaveTree2(node1.<span style="color:#a6e22e">right</span>,node2.<span style="color:#a6e22e">right</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="18jz18-二叉树的镜像">18、<strong>JZ18</strong> <strong>二叉树的镜像</strong></h2>
<p>描述</p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<pre tabindex="0"><code>比如：    源二叉树 
            8
           /  \
          6   10
         / \  / \
        5  7 9 11
        镜像二叉树
            8
           /  \
          10   6
         / \  / \
        11 9 7  5
</code></pre><p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{8,6,10,5,7,9,11}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{8,10,6,11,9,7,5}
</code></pre><p>分析：</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * public class TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   int val = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   TreeNode left = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   TreeNode right = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   public TreeNode(int val) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     this.val = val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *   }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param pRoot TreeNode类 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return TreeNode类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">Mirror</span> (TreeNode pRoot) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pRoot <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        TreeNode left <span style="color:#f92672">=</span> Mirror(pRoot.<span style="color:#a6e22e">left</span>);
</span></span><span style="display:flex;"><span>        TreeNode right <span style="color:#f92672">=</span> Mirror(pRoot.<span style="color:#a6e22e">right</span>);
</span></span><span style="display:flex;"><span>        pRoot.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>        pRoot.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> pRoot;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="19-jz19-顺时针打印矩阵">19、 <strong>JZ19</strong> <strong>顺时针打印矩阵</strong></h2>
<p>描述</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p>
<pre tabindex="0"><code>[[1,2,3,4],
[5,6,7,8],
[9,10,11,12],
[13,14,15,16]]
</code></pre><p>则依次打印出数字</p>
<pre tabindex="0"><code>[1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10]
</code></pre><p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[[1,2],[3,4]]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[1,2,4,3]
</code></pre><p>分析：</p>
<p>简单来说，就是不断地收缩矩阵的边界
定义四个变量代表范围，up、down、left、right</p>
<ol>
<li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错</li>
<li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错</li>
<li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错</li>
<li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li>
</ol>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">printMatrix</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[][]</span> matrix) {
</span></span><span style="display:flex;"><span>       ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(matrix <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> matrix.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> matrix<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> up <span style="color:#f92672">=</span> 0; <span style="color:#75715e">//第一行</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> down <span style="color:#f92672">=</span> matrix.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1; <span style="color:#75715e">//最后一行</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> 0; <span style="color:#75715e">//最左边</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> matrix<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1; <span style="color:#75715e">//最右边</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">true</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> left; col <span style="color:#f92672">&lt;=</span> right; col<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                list.<span style="color:#a6e22e">add</span>(matrix<span style="color:#f92672">[</span>up<span style="color:#f92672">][</span>col<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            up<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(up <span style="color:#f92672">&gt;</span> down){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> up; row <span style="color:#f92672">&lt;=</span> down; row<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                list.<span style="color:#a6e22e">add</span>(matrix<span style="color:#f92672">[</span>row<span style="color:#f92672">][</span>right<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(right <span style="color:#f92672">&lt;</span> left){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> col <span style="color:#f92672">=</span> right; left <span style="color:#f92672">&lt;=</span> col ; col<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                list.<span style="color:#a6e22e">add</span>(matrix<span style="color:#f92672">[</span>down<span style="color:#f92672">][</span>col<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            down<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(down <span style="color:#f92672">&lt;</span> up){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> down; row <span style="color:#f92672">&gt;=</span> up ; row<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>                list.<span style="color:#a6e22e">add</span>(matrix<span style="color:#f92672">[</span>row<span style="color:#f92672">][</span>left<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(left <span style="color:#f92672">&gt;</span> right){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="20jz20-包含min函数的栈">20、<strong>JZ20</strong> <strong>包含min函数的栈</strong></h2>
<p>描述</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)</p>
<p>push(value):将value压入栈中</p>
<p>pop():弹出栈顶元素</p>
<p>top():获取栈顶元素</p>
<p>min():获取栈中最小元素</p>
<p>示例:</p>
<p>输入:  [&ldquo;PSH-1&rdquo;,&ldquo;PSH2&rdquo;,&ldquo;MIN&rdquo;,&ldquo;TOP&rdquo;,&ldquo;POP&rdquo;,&ldquo;PSH1&rdquo;,&ldquo;TOP&rdquo;,&ldquo;MIN&rdquo;]</p>
<p>输出:  -1,2,1,-1</p>
<p>解析:</p>
<p>&ldquo;PSH-1&quot;表示将-1压入栈中，栈中元素为-1</p>
<p>&ldquo;PSH2&quot;表示将2压入栈中，栈中元素为2，-1</p>
<p>“MIN”表示获取此时栈中最小元素==&gt;返回-1</p>
<p>&ldquo;TOP&quot;表示获取栈顶元素==&gt;返回2</p>
<p>&ldquo;POP&quot;表示弹出栈顶元素，弹出2，栈中元素为-1</p>
<p>&ldquo;PSH-1&quot;表示将1压入栈中，栈中元素为1，-1</p>
<p>&ldquo;TOP&quot;表示获取栈顶元素==&gt;返回1</p>
<p>“MIN”表示获取此时栈中最小元素==&gt;返回-1</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code> [&#34;PSH-1&#34;,&#34;PSH2&#34;,&#34;MIN&#34;,&#34;TOP&#34;,&#34;POP&#34;,&#34;PSH1&#34;,&#34;TOP&#34;,&#34;MIN&#34;]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>-1,2,1,-1
</code></pre><p>分析：借助辅助栈</p>
<p>首先需要一个正常栈normal,用于栈的正常操作，然后需要一个辅助栈minval，专门用于获取最小值</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/284295_1587290406796_0EDB8C9599BA026855B6DCCC1D5EDAE5" alt=" " style="zoom:67%;" /> 
<p>时间复杂度：O(1)
空间复杂度：O(n), 开辟了一个辅助栈。</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Stack;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;</span>(); 
</span></span><span style="display:flex;"><span>    Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;</span>(); 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> node) {
</span></span><span style="display:flex;"><span>        stack1.<span style="color:#a6e22e">push</span>(node);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(stack2.<span style="color:#a6e22e">empty</span>()){
</span></span><span style="display:flex;"><span>            stack2.<span style="color:#a6e22e">push</span>(node);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            stack2.<span style="color:#a6e22e">push</span>(Math.<span style="color:#a6e22e">min</span>(node,stack2.<span style="color:#a6e22e">peek</span>()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        stack1.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>        stack2.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stack1.<span style="color:#a6e22e">peek</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">min</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stack2.<span style="color:#a6e22e">peek</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="21jz21-栈的压入弹出序列">21、<strong>JZ21</strong> <strong>栈的压入、弹出序列</strong></h2>
<p>描述</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[1,2,3,4,5],[4,3,5,1,2]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>false
</code></pre><p>分析：新建一个栈，将数组A压入栈中，当栈顶元素等于数组B时，就将其出栈，当循环结束时，判断栈是否为空，若为空则返回true.</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">时间复杂度：O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">空间复杂度：O(n), 用了一个辅助栈，最坏情况下会全部入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">IsPopOrder</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> pushA,<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> popA) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pushA.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">||</span> popA.<span style="color:#a6e22e">length</span> <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> pushA.<span style="color:#a6e22e">length</span>; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            stack.<span style="color:#a6e22e">push</span>(pushA<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stack.<span style="color:#a6e22e">isEmpty</span>() <span style="color:#f92672">&amp;&amp;</span> stack.<span style="color:#a6e22e">peek</span>() <span style="color:#f92672">==</span> popA<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> ){
</span></span><span style="display:flex;"><span>                stack.<span style="color:#a6e22e">pop</span>();
</span></span><span style="display:flex;"><span>                j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stack.<span style="color:#a6e22e">isEmpty</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="22jz22-从上往下打印二叉树">22、<strong>JZ22</strong> <strong>从上往下打印二叉树</strong></h2>
<p>描述</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{5,4,#,3,#,2,#,1}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[5,4,3,2,1]
</code></pre><p>分析：</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728161409544.png" alt="image-20210728161409544" style="zoom: 80%;" /> 
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*思路是用arraylist模拟一个队列来存储相应的TreeNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">PrintFromTopToBottom</span>(TreeNode root) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Deque<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> deque <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>(); <span style="color:#75715e">//将节点放入队列</span>
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        deque.<span style="color:#a6e22e">addLast</span>(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>deque.<span style="color:#a6e22e">isEmpty</span>()){
</span></span><span style="display:flex;"><span>            TreeNode node <span style="color:#f92672">=</span> deque.<span style="color:#a6e22e">pollFirst</span>();
</span></span><span style="display:flex;"><span>            list.<span style="color:#a6e22e">add</span>(node.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node.<span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>                deque.<span style="color:#a6e22e">addLast</span>(node.<span style="color:#a6e22e">left</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node.<span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>                deque.<span style="color:#a6e22e">addLast</span>(node.<span style="color:#a6e22e">right</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="23jz23-二叉搜索树的后序遍历序列">23、<strong>JZ23</strong> <strong>二叉搜索树的后序遍历序列</strong></h2>
<p>描述</p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜索树）</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[4,8,6,12,16,14,10]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>true
</code></pre><p>分析：
思路通过根节点，将数组划分为两部分，假设根节点为x，则左子树 &lt; x , 右子树 &gt; x。通过递归即可，递归的每一层都涉及到对序列的遍历，虽然层数越深节点越少（少了子树的根节点），但是这种减少是微不足道的，即使是到了最底层，依旧有n/2的节点（完美二叉树第i层节点数是其上所有节点数之和+1），因此递归方法在每一层的遍历开销是O(n)，而对于二叉树而言，递归的层数平均是O(logn)，因此，递归方法的最终复杂度是O(nlogn).</p>
<p><a href="https://blog.nowcoder.net/n/8fe97e67996249ccbe71328d3a49c4af?f=comment">另一种大神解法上限约束法</a></p>
 <img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728213700344.png" alt="image-20210728213700344" style="zoom:80%;" /> 
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210728213620840.png" alt="image-20210728213620840" style="zoom:80%;" /> 
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*时间复杂度：O(nlogn）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">VerifySquenceOfBST</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> sequence) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span>(sequence.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> num : sequence){
</span></span><span style="display:flex;"><span>            list.<span style="color:#a6e22e">add</span>(num);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> VerifyBST(list);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span>  <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">VerifyBST</span>(ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(list.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">&lt;</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//递归结束条件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> list.<span style="color:#a6e22e">get</span>(list.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> leftList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> rightList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(list.<span style="color:#a6e22e">get</span>(i) <span style="color:#f92672">&lt;</span> mid){
</span></span><span style="display:flex;"><span>            leftList.<span style="color:#a6e22e">add</span>(list.<span style="color:#a6e22e">get</span>(i<span style="color:#f92672">++</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(list.<span style="color:#a6e22e">get</span>(i) <span style="color:#f92672">&gt;</span> mid){
</span></span><span style="display:flex;"><span>            rightList.<span style="color:#a6e22e">add</span>(list.<span style="color:#a6e22e">get</span>(i<span style="color:#f92672">++</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&lt;</span> list.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">-</span> 1){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//判断是否走完数组列表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//正常走完数组 i = list.size() - 1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> VerifyBST(leftList) <span style="color:#f92672">&amp;&amp;</span> VerifyBST(rightList);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="24jz24-二叉树中和为某一值的路径">24、<strong>JZ24</strong> <strong>二叉树中和为某一值的路径</strong></h2>
<p>描述</p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{10,5,12,4,7},22
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[[10,5,7],[10,12]]
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>{10,5,12,4,7},15
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[]
</code></pre><p>分析：使用深度优先遍历（DFS）</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ArrayList<span style="color:#f92672">&lt;</span>ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> resultList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> tempList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">FindPath</span>(TreeNode root,<span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//叶子节点走完返回列表</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> resultList;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        tempList.<span style="color:#a6e22e">add</span>(root.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root.<span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> root.<span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> target <span style="color:#f92672">-</span> root.<span style="color:#a6e22e">val</span> <span style="color:#f92672">==</span> 0){
</span></span><span style="display:flex;"><span>            resultList.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>(tempList));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        FindPath(root.<span style="color:#a6e22e">left</span>, target <span style="color:#f92672">-</span> root.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>        FindPath(root.<span style="color:#a6e22e">right</span>, target <span style="color:#f92672">-</span> root.<span style="color:#a6e22e">val</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//移除最后一个元素，深度遍历完一条路径后要回退</span>
</span></span><span style="display:flex;"><span>        tempList.<span style="color:#a6e22e">remove</span>(tempList.<span style="color:#a6e22e">size</span>()<span style="color:#f92672">-</span>1);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> resultList;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="25jz25-复杂链表的复制">25、<strong>JZ25</strong> <strong>复杂链表的复制</strong></h2>
<p>描述</p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210729154454708.png" alt="image-20210729154454708" style="zoom:50%;" />  
<p>示例:</p>
<p>输入:{1,2,3,4,5,3,5,#,2,#}</p>
<p>输出:{1,2,3,4,5,3,5,#,2,#}</p>
<p>解析:我们将链表分为两段，前半部分{1,2,3,4,5}为ListNode，后半部分{3,5,#,2,#}是随机指针域表示。</p>
<p>以上示例前半部分可以表示链表为的ListNode:1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>后半部分，3，5，#，2，#分别的表示为</p>
<p>1的位置指向3，2的位置指向5，3的位置指向null，4的位置指向2，5的位置指向null</p>
<p>如下图:</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/image-20210729154430590.png" alt="image-20210729154430590" style="zoom:67%;" /> 
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{1,2,3,4,5,3,5,#,2,#}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>{1,2,3,4,5,3,5,#,2,#}
</code></pre><p>分析：</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">public class RandomListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int label;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    RandomListNode next = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    RandomListNode random = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    RandomListNode(int label) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        this.label = label;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.*;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    HashMap<span style="color:#f92672">&lt;</span>RandomListNode,RandomListNode<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> RandomListNode <span style="color:#a6e22e">Clone</span>(RandomListNode pHead) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pHead <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(map.<span style="color:#a6e22e">containsKey</span>(pHead)){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> map.<span style="color:#a6e22e">get</span>(pHead);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        RandomListNode tempNode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RandomListNode(pHead.<span style="color:#a6e22e">label</span>);
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(pHead, tempNode);
</span></span><span style="display:flex;"><span>        tempNode.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> Clone(pHead.<span style="color:#a6e22e">next</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//         tempNode.random = Clone(pHead.random); // 这一步目的：防止cannot used original node of list</span>
</span></span><span style="display:flex;"><span>        tempNode.<span style="color:#a6e22e">random</span> <span style="color:#f92672">=</span> map.<span style="color:#a6e22e">get</span>(pHead.<span style="color:#a6e22e">random</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> tempNode;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="26jz26-二叉搜索树与双向链表">26、<strong>JZ26</strong> <strong>二叉搜索树与双向链表</strong></h2>
<p>描述</p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p>
<img src="https://gitee.com/aaronlynn/picture/raw/master/img/E1F1270919D292C9F48F51975FD07CE2" alt="img" style="zoom: 33%;" /> 
<p>注意:</p>
<p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
2.返回链表中的第一个节点的指针
3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构
4.你不用输出或者处理，示例中输出里面的英文，比如&quot;From left to right are:&ldquo;这样的，程序会根据你的返回值自动打印输出</p>
<p>示例:</p>
<p>输入: {10,6,14,4,8,12,16}</p>
<p>输出:From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;</p>
<p>解析:</p>
<p>输入就是一棵二叉树，如上图，输出的时候会将这个双向链表从左到右输出，以及从右到左输出，确保答案的正确</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>{10,6,14,4,8,12,16}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>{5,4,#,3,#,2,#,1}
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
</code></pre><p>说明：</p>
<pre tabindex="0"><code>                    5
                  /
                4
              /
            3
          /
        2
      /
    1
树的形状如上图  
</code></pre><p>分析：</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">public class TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int val = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    TreeNode left = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    TreeNode right = null;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    public TreeNode(int val) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        this.val = val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">Convert</span>(TreeNode pRootOfTree) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="27jz27-字符串的排列">27、<strong>JZ27</strong> <strong>字符串的排列</strong></h2>
<p>描述</p>
<p>输入一个字符串，打印出该字符串中字符的所有排列，你可以以任意顺序返回这个字符串数组。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<p>输入描述：</p>
<p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>&#34;ab&#34;
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[&#34;ab&#34;,&#34;ba&#34;]
</code></pre><p>说明：</p>
<pre tabindex="0"><code>返回[&#34;ba&#34;,&#34;ab&#34;]也是正确的  
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>&#34;aab&#34;
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[&#34;aab&#34;,&#34;aba&#34;,&#34;baa&#34;]
</code></pre><p>示例3</p>
<p>输入：</p>
<pre tabindex="0"><code>&#34;abc&#34;
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>[&#34;abc&#34;,&#34;acb&#34;,&#34;bac&#34;,&#34;bca&#34;,&#34;cab&#34;,&#34;cba&#34;]
</code></pre><p>分析：</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ArrayList<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">Permutation</span>(String str) {
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="28-jz28-数组中出现次数超过一半的数字">28、 <strong>JZ28</strong> <strong>数组中出现次数超过一半的数字</strong></h2>
<p>描述</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1&lt;=数组长度&lt;=50000，0&lt;=数组元素&lt;=10000</p>
<p>示例1</p>
<p>输入：</p>
<pre tabindex="0"><code>[1,2,3,2,2,2,5,4,2]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>2
</code></pre><p>示例2</p>
<p>输入：</p>
<pre tabindex="0"><code>[3,3,3,3,2,2,2]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>3
</code></pre><p>示例3</p>
<p>输入：</p>
<pre tabindex="0"><code>[1]
</code></pre><p>返回值：</p>
<pre tabindex="0"><code>1
</code></pre><p>分析：</p>
<p>题解：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">MoreThanHalfNum_Solution</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> array) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
      </article>
    </section>

    

    
    <article class="ui segment utterances-comments" data-html2canvas-ignore>
      <script
        src="https://utteranc.es/client.js"
        repo="recordnote/recordnote.github.io"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
      </script>
    </article>
    

    
  </div>
</div>


            <footer class="ui basic center aligned segment" style="background-color: transparent;">
              
              <p>© 2019 - 2024 Lin 的博客</p>
              

              <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

              
            </footer>
          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <header class="ui basic very padded segment dream-header">
  
  <div class="ui small circular image">
    <img src="/me/yy.jpg" alt="avatar" />
  </div>
  

  <div class="content">
    <h1 class="ui medium header">Lin 的博客<span class="sub header">A merry heart goes all the way.</span>
    </h1>

    <article class="ui horizontal list">
      
      <a class="item" href="/posts">
        <i class="archive icon" title="归档"></i>
      </a>
      
      <a class="item" href="/categories">
        <i class="th list icon" title="所有分类"></i>
      </a>
      <a class="item" href="/tags">
        <i class="tags icon" title="所有标签"></i>
      </a>
    </article>

    
    
    
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    

    

    
    
    
          <div class="dream-tags">
          
          
          
            <a class="ui label" href="/tags/java/" title="Java">
              Java
            </a>
          
          
          
            <a class="ui label" href="/tags/spring/" title="Spring">
              Spring
            </a>
          
          
          
            <a class="ui label" href="/tags/%E5%89%8D%E7%AB%AF/" title="前端">
              前端
            </a>
          
          
          
            <a class="ui label" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务">
              微服务
            </a>
          
          
          
            <a class="ui label" href="/tags/%E6%84%9F%E6%82%9F/" title="感悟">
              感悟
            </a>
          
          
          
            <a class="ui label" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库">
              数据库
            </a>
          
          
          
            <a class="ui label" href="/tags/%E6%9D%82%E8%B0%88/" title="杂谈">
              杂谈
            </a>
          
          
          
            <a class="ui label" href="/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="架构设计">
              架构设计
            </a>
          
          
          
            <a class="ui label" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" title="消息队列">
              消息队列
            </a>
          
          
          
            <a class="ui label" href="/tags/%E7%94%9F%E6%B4%BB/" title="生活">
              生活
            </a>
          
          
          
            <a class="ui label" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="算法与数据结构">
              算法与数据结构
            </a>
          
          
          
            <a class="ui label" href="/tags/%E8%BF%90%E7%BB%B4/" title="运维">
              运维
            </a>
          
          </div>
    

    
  </div>
</header>


<div class="ui relaxed grid dream-grid dream-back">
  
  
  
  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment markdown-body">
      <div class="ui medium header">关于我</div>
      <p>Lin 的 ❤️ 博客</p>
<p>记录一些 🌈 生活上，技术上的事</p>
<p>职业是JAVA全栈工程师</p>

    </article>
  </div>
  

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment">
      <div class="ui medium header">社交链接</div>
      <nav class="ui secondary menu dream-menu dream-socials">
  
  <div class="item">
    <a href="/index.xml">
      <i class="large rss square icon" title="RSS"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="mailto:zhjlynn@foxmail.com">
      <i class="large mail icon" title="Email"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="https://twitter.com/Lin" target="_blank">
      <i class="large twitter icon" title="Twitter"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="https://facebook.com/Lin" target="_blank">
      <i class="large facebook icon" title="Facebook"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="https://instagram.com/Lin" target="_blank">
      <i class="large instagram icon" title="Instagram"></i>
    </a>
  </div>
  

  

  
  <div class="item">
    <a href="https://www.linkedin.com/in/Lin" target="_blank">
      <i class="large linkedin icon" title="Linkedin"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="https://github.com/Lin" target="_blank">
      <i class="large github icon" title="GitHub"></i>
    </a>
  </div>
  

  
  <div class="item">
    <a href="https://www.stackoverflow.com/users/Lin" target="_blank">
      <i class="large stack overflow icon" title="StackOverflow"></i>
    </a>
  </div>
  

  
</nav>

    </article>
  </div>

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
    <article class="ui segment">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br /><br />背景使用了 <a href="https://www.pexels.com/zh-cn/" target="_blank">Pexels</a> 上 <a href="https://www.pexels.com/zh-cn/Ungaro" target="_blank">Francesco Ungaro</a> 拍摄的<a href="https://www.pexels.com/zh-cn/photo/1454794/" target="_blank">图片</a>。
    </article>
    
  </div>

  
</div>

          </div>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>

    
    <div class="ui segment" id="dream-search">
  <div class="ui search">
    <div class="ui transparent input">
      <input class="prompt" type="text" placeholder="搜索" />
    </div>
    <div class="results"></div>
  </div>
</div>
<script>
  $(document).ready(function () {
    $.getJSON('https:\/\/recordnote.github.io\//index.json', function (data) {
      $('.ui.search').search({
        source: data,
        searchFields: ['title'],
        showNoResults: false,
      })
    })
  })
</script>
<script src="/js/search.js"></script>

    

    

    <script>
  window.background = "#fff"
  window.defaultDark =  null 
  window.backgroundDark = "#333"
  window.backgroundImageDark = "/me/background.jpg"
  window.darkNav =  null 
  window.maxTags =  null 
  window.hasTwitterEmbed =  null 
  window.fixedNav =  true 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/overlayscrollbars@1.13.1/js/jquery.overlayScrollbars.min.js"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>

    


<script src="https://cdn.jsdelivr.net/npm/luxon@1.26.0"></script>

<script>
  format()

  function format() {
    $('span[data-format="luxon"]').each(function () {
      var date = $(this).text()

      $(this).text(luxon.DateTime.fromISO(date, { locale: "zh" }).toFormat("yyyy年MM月dd日"))
    })
  }
</script>



<script src="/js/scrollToTop.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>



<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/clojure.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js"></script>



<script>
  hljs.highlightAll()
  setHighlightTheme()

  function setHighlightTheme() {
    var isDark = localStore.getItem('hugo-theme-dream-is-dark')
    isDark = isDark ? isDark : window.defaultDark ? 'y' : isDark

    var lightTheme = "tomorrow"
    var darkTheme = "tomorrow-night"
    var theme = isDark === 'y' ? darkTheme : lightTheme

    $('link[data-highlight]').attr('href', 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/' + theme + '.min.css')
    $('pre').css('background', isDark === 'y' ? '#333' : '')
  }
</script>



<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.1"></script>
<script src="/js/post.js" defer></script>


    

    
    
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-98295641-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </body>
</html>
